{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FlubuCore \u00b6 Introduction \u00b6 \"FlubuCore - Fluent Builder Core\" is a cross platform build and deployment automation system. You can define your build and deployment scripts in C# using an intuitive fluent interface. This gives you code completion, IntelliSense, debugging, FlubuCore custom analyzers, and native access to the whole .NET ecosystem inside of your scripts. FlubuCore offers a .net (core) console application that uses power of roslyn to compile and execute scripts. Above example can be run from console with: FlubuCore runner flubu.exe Default FlubuCore dotnet cli tool dotnet flubu Default FlubuCore global tool flubu Default Features and Advantages \u00b6 Intuitive an easy to learn. C#, fluent interface, and IntelliSense make even most complex script creation a breeze. 1 2 3 4 5 context . CreateTarget ( \"Example\" ) . DependsOn ( fetchBuildVersionTarget ) . AddTask ( x => x . CompileSolutionTask ()) . AddTask ( x => x . PublishNuGetPackageTask ( \"packageId\" , \"pathToNuspec\" )) . When ( c => c . BuildSystems (). Jenkins (). IsRunningOnJenkins ); Large number of often used built-in tasks like e.g. running tests, managing IIS, creating deployment packages, publishing NuGet packages, docker tasks, executing PowerShell scripts and many more. 1 2 3 4 5 6 target . AddTask ( x => x . CompileSolutionTask ()) . AddTask ( x => x . CopyFileTask ( source , destination , true )) . AddTask ( x => x . IisTasks () . CreateAppPoolTask ( \"Example app pool\" ) . Mode ( CreateApplicationPoolMode . DoNothingIfExists )); Execute your own custom C# code. 1 2 3 4 context . CreateTarget ( \"MyCustomBuildTarget\" ) . AddTask ( x => x . CompileSolutionTask ()) . Do ( MyCustomMethod ) . Do ( NuGetPackageReferencingExample ); assembly references and nuget packages are loaded automatically when script is used together with project file. When script is executed alone (for example when deploying with FlubuCore script on production environment) references can be added with attributes. 1 2 3 4 5 6 7 8 9 [NugetPackage(\"Newtonsoft.json\", \"11.0.2\")] [Assembly(\".\\Lib\\EntityFramework.dll\")] public class BuildScript : DefaultBuildScript { public void NuGetPackageReferencingExample ( ITaskContext context ) { JsonConvert . SerializeObject ( \"Example\" ); } } Easily run any external program or console command in your script. 1 2 3 4 5 6 7 8 9 10 11 public class SimpleScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Run.Libz\" ) . AddTask ( x => x . RunProgramTask ( @\"packages\\LibZ.Tool\\1.2.0\\tools\\libz.exe\" ) . WorkingFolder ( @\".\\src\" ) . WithArguments ( \"add\" ) . WithArguments ( \"--libz\" , \"Assemblies.libz\" )); } } Pass command line arguments, settings from json configuration file or environment variables to your script. 1 2 3 4 5 6 7 8 9 10 11 12 13 public class SimpleScript : DefaultBuildScript { [FromArg(\"sn\", \"If true app is deployed on second node. Otherwise not.\")] public bool deployOnSecondNode { get ; set ; } protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"compile\" ) . AddTask ( x => x . CompileSolutionTask () . ForMember ( y => y . SolutionFileName ( \"someSolution.sln\" ), \"solution\" , \"The solution to build.\" )); } } 1 flubu.exe compile -solution=someOtherSolution.sln -sn=true Extending FlubuCore fluent interface by writing your own tasks within FlubuCore plugins. 1 2 3 4 5 6 7 8 public class ExampleFlubuPluginTask : TaskBase < int , ExampleFlubuPluginTask > { protected override int DoExecute ( ITaskContextInternal context ) { // Write your task logic here. return 0 ; } } Growing list of FlubuCore plugins complements built in tasks. Asynchronous execution of tasks, target dependencies and custom code. 1 2 3 4 context . CreateTarget ( \"Run.Tests\" ) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName3\" )); Override existing options or add additional options to tasks through console 1 2 context . CreateTarget ( \"Example\" ) ` . AddCoreTask ( x => x . Build ( \"MySolution.sln\" ). Configuration ( \"Release\" ); flubu build /o:configuration=Debug flubu would execute dotnet build MySolution.sln -c Debug Full .NET Core support including the global CLI tool 1 2 dotnet tool install --global FlubuCore.GlobalTool flubu compile Possibility to test and debug your build scripts. 1 context . WaitForDebugger (); Easily automate deployments remotely via the FlubuCore Web API. Possibility to use FlubuCore tasks in any other .NET application. FlubuCore interactive mode which offers target tab completition, options tab completition, toogle targets and options, executed commands history and more... Improved developer experience with FlubuCore custom analyzers. Getting Started \u00b6 Using FlubuCore is straightforward and very simple :-) It is also fully and throughly documented. The Getting Started chapter in Documentation will help you set up your first FlubuCore build in no time. A comprehensive list of features that FlubuCore has to offer with descriptions can be found in the Build Script Fundamentals chapter. Once you have your build and deployment scripts defined, the following Wiki chapters will explain how to run them: For .NET Framework projects use FlubuCore.Runner For .NET Core projects use FlubuCore CLI global tool Examples \u00b6 Aside from the detailed Wiki FlubuCore comes with example projects that reflect real-life situations. The examples can be found in the separate Examples repository . These examples will help you to get quickly start with FlubuCore: * .NET Framework build example .NET Core build example Deployment script example Have a question? \u00b6 Contributing \u00b6 Please see CONTRIBUTING.md . Ways to Contribute \u00b6 Spread the word about the project. If you like the project don't forget to give it a star so that the community get's bigger. Improve documentation. Report, fix a bug. Implement a new feature. Discuss potential ways to improve project. Improve existing implementation, performance, etc. Changelog and Roadmap \u00b6 Changes with description and examples can be found in Changelog. You can see FlubuCore roadmap by exploring opened Milestones.","title":"FlubuCore"},{"location":"#flubucore","text":"","title":"FlubuCore"},{"location":"#introduction","text":"\"FlubuCore - Fluent Builder Core\" is a cross platform build and deployment automation system. You can define your build and deployment scripts in C# using an intuitive fluent interface. This gives you code completion, IntelliSense, debugging, FlubuCore custom analyzers, and native access to the whole .NET ecosystem inside of your scripts. FlubuCore offers a .net (core) console application that uses power of roslyn to compile and execute scripts. Above example can be run from console with: FlubuCore runner flubu.exe Default FlubuCore dotnet cli tool dotnet flubu Default FlubuCore global tool flubu Default","title":"Introduction"},{"location":"#features-and-advantages","text":"Intuitive an easy to learn. C#, fluent interface, and IntelliSense make even most complex script creation a breeze. 1 2 3 4 5 context . CreateTarget ( \"Example\" ) . DependsOn ( fetchBuildVersionTarget ) . AddTask ( x => x . CompileSolutionTask ()) . AddTask ( x => x . PublishNuGetPackageTask ( \"packageId\" , \"pathToNuspec\" )) . When ( c => c . BuildSystems (). Jenkins (). IsRunningOnJenkins ); Large number of often used built-in tasks like e.g. running tests, managing IIS, creating deployment packages, publishing NuGet packages, docker tasks, executing PowerShell scripts and many more. 1 2 3 4 5 6 target . AddTask ( x => x . CompileSolutionTask ()) . AddTask ( x => x . CopyFileTask ( source , destination , true )) . AddTask ( x => x . IisTasks () . CreateAppPoolTask ( \"Example app pool\" ) . Mode ( CreateApplicationPoolMode . DoNothingIfExists )); Execute your own custom C# code. 1 2 3 4 context . CreateTarget ( \"MyCustomBuildTarget\" ) . AddTask ( x => x . CompileSolutionTask ()) . Do ( MyCustomMethod ) . Do ( NuGetPackageReferencingExample ); assembly references and nuget packages are loaded automatically when script is used together with project file. When script is executed alone (for example when deploying with FlubuCore script on production environment) references can be added with attributes. 1 2 3 4 5 6 7 8 9 [NugetPackage(\"Newtonsoft.json\", \"11.0.2\")] [Assembly(\".\\Lib\\EntityFramework.dll\")] public class BuildScript : DefaultBuildScript { public void NuGetPackageReferencingExample ( ITaskContext context ) { JsonConvert . SerializeObject ( \"Example\" ); } } Easily run any external program or console command in your script. 1 2 3 4 5 6 7 8 9 10 11 public class SimpleScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Run.Libz\" ) . AddTask ( x => x . RunProgramTask ( @\"packages\\LibZ.Tool\\1.2.0\\tools\\libz.exe\" ) . WorkingFolder ( @\".\\src\" ) . WithArguments ( \"add\" ) . WithArguments ( \"--libz\" , \"Assemblies.libz\" )); } } Pass command line arguments, settings from json configuration file or environment variables to your script. 1 2 3 4 5 6 7 8 9 10 11 12 13 public class SimpleScript : DefaultBuildScript { [FromArg(\"sn\", \"If true app is deployed on second node. Otherwise not.\")] public bool deployOnSecondNode { get ; set ; } protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"compile\" ) . AddTask ( x => x . CompileSolutionTask () . ForMember ( y => y . SolutionFileName ( \"someSolution.sln\" ), \"solution\" , \"The solution to build.\" )); } } 1 flubu.exe compile -solution=someOtherSolution.sln -sn=true Extending FlubuCore fluent interface by writing your own tasks within FlubuCore plugins. 1 2 3 4 5 6 7 8 public class ExampleFlubuPluginTask : TaskBase < int , ExampleFlubuPluginTask > { protected override int DoExecute ( ITaskContextInternal context ) { // Write your task logic here. return 0 ; } } Growing list of FlubuCore plugins complements built in tasks. Asynchronous execution of tasks, target dependencies and custom code. 1 2 3 4 context . CreateTarget ( \"Run.Tests\" ) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName3\" )); Override existing options or add additional options to tasks through console 1 2 context . CreateTarget ( \"Example\" ) ` . AddCoreTask ( x => x . Build ( \"MySolution.sln\" ). Configuration ( \"Release\" ); flubu build /o:configuration=Debug flubu would execute dotnet build MySolution.sln -c Debug Full .NET Core support including the global CLI tool 1 2 dotnet tool install --global FlubuCore.GlobalTool flubu compile Possibility to test and debug your build scripts. 1 context . WaitForDebugger (); Easily automate deployments remotely via the FlubuCore Web API. Possibility to use FlubuCore tasks in any other .NET application. FlubuCore interactive mode which offers target tab completition, options tab completition, toogle targets and options, executed commands history and more... Improved developer experience with FlubuCore custom analyzers.","title":"Features and Advantages"},{"location":"#getting-started","text":"Using FlubuCore is straightforward and very simple :-) It is also fully and throughly documented. The Getting Started chapter in Documentation will help you set up your first FlubuCore build in no time. A comprehensive list of features that FlubuCore has to offer with descriptions can be found in the Build Script Fundamentals chapter. Once you have your build and deployment scripts defined, the following Wiki chapters will explain how to run them: For .NET Framework projects use FlubuCore.Runner For .NET Core projects use FlubuCore CLI global tool","title":"Getting Started"},{"location":"#examples","text":"Aside from the detailed Wiki FlubuCore comes with example projects that reflect real-life situations. The examples can be found in the separate Examples repository . These examples will help you to get quickly start with FlubuCore: * .NET Framework build example .NET Core build example Deployment script example","title":"Examples"},{"location":"#have-a-question","text":"","title":"Have a question?"},{"location":"#contributing","text":"Please see CONTRIBUTING.md .","title":"Contributing"},{"location":"#ways-to-contribute","text":"Spread the word about the project. If you like the project don't forget to give it a star so that the community get's bigger. Improve documentation. Report, fix a bug. Implement a new feature. Discuss potential ways to improve project. Improve existing implementation, performance, etc.","title":"Ways to Contribute"},{"location":"#changelog-and-roadmap","text":"Changes with description and examples can be found in Changelog. You can see FlubuCore roadmap by exploring opened Milestones.","title":"Changelog and Roadmap"},{"location":"Tests-debugging/","text":"Writing build script tests and debuging build script through test \u00b6 Wiki coming soon. Meanwhile see simple test to get you started: https://github.com/flubu-core/examples/blob/master/NetCore_csproj/BuildScript/BuildScriptTests.cs If needed you can debug build script through test. You can use flubu task in other .net applications just like in above test example. Debugging build script by attaching to running process \u00b6 You can debug build script by attaching debuger to Flubu process. Because Flubu alters build script slightly you have to disable option 'Require source code files to exactly match the original version' in visual studio. Option can be found under Tools->Options->Debugging->General->Require source code files to exactly match the original version. Not sure for VS code if any settings have to be changed. It is advised to use WaitForDebugger extension method on ITaskContext before first break point 1 2 3 4 protected override void ConfigureTargets(ITaskContext context) { context.WaitForDebugger(); } Run build script and attach debugger to FlubuCore process. FlubuCore process name vary depending on which FlubuCore \"runner\" you are using. FlubuCore.Runner - You have to attach debugger to process named flubu.exe dotnet-flubu Cli tool - You have to attach debugger to right process named dotnet FlubuCore.GlobalTool - You have to attach debugger to process named Flubu","title":"Tests and debuging"},{"location":"Tests-debugging/#writing-build-script-tests-and-debuging-build-script-through-test","text":"Wiki coming soon. Meanwhile see simple test to get you started: https://github.com/flubu-core/examples/blob/master/NetCore_csproj/BuildScript/BuildScriptTests.cs If needed you can debug build script through test. You can use flubu task in other .net applications just like in above test example.","title":"Writing build script tests and debuging build script through test"},{"location":"Tests-debugging/#debugging-build-script-by-attaching-to-running-process","text":"You can debug build script by attaching debuger to Flubu process. Because Flubu alters build script slightly you have to disable option 'Require source code files to exactly match the original version' in visual studio. Option can be found under Tools->Options->Debugging->General->Require source code files to exactly match the original version. Not sure for VS code if any settings have to be changed. It is advised to use WaitForDebugger extension method on ITaskContext before first break point 1 2 3 4 protected override void ConfigureTargets(ITaskContext context) { context.WaitForDebugger(); } Run build script and attach debugger to FlubuCore process. FlubuCore process name vary depending on which FlubuCore \"runner\" you are using. FlubuCore.Runner - You have to attach debugger to process named flubu.exe dotnet-flubu Cli tool - You have to attach debugger to right process named dotnet FlubuCore.GlobalTool - You have to attach debugger to process named Flubu","title":"Debugging build script by attaching to running process"},{"location":"build-script-runner-interactive/","text":"When executing flubu script or any other process locally in console it is recomended to run FlubuCore in interactive mode it gives you some really nice features which are listed in the features section. To start FlubuCore interactive mode just execute command flubu -i in your favorite console. Demo \u00b6 Build script used in demo. Features \u00b6 Features in interactive mode Target's tab completition with tab key Option's tab completition with tab key Target help displayed at the bottom of console Option help displayed at the bottom of console Execute external commands. Meaning if you run FlubuCore interactive mode for example in powershell all powershell commands are available in FlubuCore interactive mode. Execute external processes. For some of them FlubuCore offers tab completion with help at the bottom of console out of the box(such as dotnet, git... See full list ) Next / previos target with up and down arrow Next / previos option with up and down arrow History of executed commans with up and down arrow No need to load script for each executed target reload or load another script Navigation beatwen folders Internal commands \u00b6 cd change directory. dir list files and directories l|load -s={script} Load another FlubuCore script. r|reload Reload currently loaded script. e|q|exit|quit Exit Flubu Core interactive mode. Hot keys \u00b6 Following hot keys are supported: Enter Executes entered command Tab completes user's input with active target/option hint (if found) Up arrow select previous command from history if user's input is empty or select previous hint (if possible) Down arrow select next command from history if user's input is empty or select next hint (if possible) Left arrow move cursor left Right arrow move cursor right Backspace removes character before cursor Delete removes character under cursor Home move cursor to the beginning of user's input End move cursor to the end of user's input External processes tab completion list \u00b6 List of external processes for which tab completion of options/switches is available in FlubuCore interactive mode. it is planned that all docker, octopus, azure, npm and chocolatey commands will also be supported in the near feature. dotnet build dotnet test dotnet pack dotnet publish dotnet nuget push dotnet restore dotnet tool install dotnet tool update dotnet tool uniinstall git add git commit git push git checkout git clone git submodule git rm git tag gitversion coverlet sqlcmd.exe","title":"Build script runner interactive mode"},{"location":"build-script-runner-interactive/#demo","text":"Build script used in demo.","title":"Demo"},{"location":"build-script-runner-interactive/#features","text":"Features in interactive mode Target's tab completition with tab key Option's tab completition with tab key Target help displayed at the bottom of console Option help displayed at the bottom of console Execute external commands. Meaning if you run FlubuCore interactive mode for example in powershell all powershell commands are available in FlubuCore interactive mode. Execute external processes. For some of them FlubuCore offers tab completion with help at the bottom of console out of the box(such as dotnet, git... See full list ) Next / previos target with up and down arrow Next / previos option with up and down arrow History of executed commans with up and down arrow No need to load script for each executed target reload or load another script Navigation beatwen folders","title":"Features"},{"location":"build-script-runner-interactive/#internal-commands","text":"cd change directory. dir list files and directories l|load -s={script} Load another FlubuCore script. r|reload Reload currently loaded script. e|q|exit|quit Exit Flubu Core interactive mode.","title":"Internal commands"},{"location":"build-script-runner-interactive/#hot-keys","text":"Following hot keys are supported: Enter Executes entered command Tab completes user's input with active target/option hint (if found) Up arrow select previous command from history if user's input is empty or select previous hint (if possible) Down arrow select next command from history if user's input is empty or select next hint (if possible) Left arrow move cursor left Right arrow move cursor right Backspace removes character before cursor Delete removes character under cursor Home move cursor to the beginning of user's input End move cursor to the end of user's input","title":"Hot keys"},{"location":"build-script-runner-interactive/#external-processes-tab-completion-list","text":"List of external processes for which tab completion of options/switches is available in FlubuCore interactive mode. it is planned that all docker, octopus, azure, npm and chocolatey commands will also be supported in the near feature. dotnet build dotnet test dotnet pack dotnet publish dotnet nuget push dotnet restore dotnet tool install dotnet tool update dotnet tool uniinstall git add git commit git push git checkout git clone git submodule git rm git tag gitversion coverlet sqlcmd.exe","title":"External processes tab completion list"},{"location":"build-script-runner/","text":"In .NET you run flubu build scripts with console application flubu.exe. Add Flubu.Runner nuget to get the console application. In .NET core you run flubu build scripts with dotnet command line tool or global tool. How to install tools see Getting started section Usage \u00b6 .NET core usage: dotnet flubu {TargetToExecute} {Flubu options} {build script arguments} .NET core global tool usage: flubu {TargetToExecute} {Flubu options} {build script arguments} .NET usage: flubu.exe {TargetToExecute} {Flubu options} {build script arguments} Multiple target execution \u00b6 .NET core usage: dotnet flubu {TargetToExecute} {TargetToExecute2} {TargetToExecute3...} {Options} .NET usage: flubu.exe {TargetToExecute} {TargetToExecute2} {TargetToExecute3...} {Options} Target's can be executed in parallel with added -parallel option Flubu options \u00b6 target help \u00b6 List all available targets: flubu help dotnet flubu help Target specific help: flubu {TargetName} help dotnet flubu {TargetName} help It displays all tasks with description that will be executed by target. It also displays which argument(with description) can be passed through to specific task in target. Default build script locations \u00b6 \u201cBuildScript.cs\u201d \u201cDeployScript.cs\u201d \u201cBuildScript/BuildScript.cs\u201d \u201cbuildscript/deployscript.cs\u201d \u201cbuildscripts/buildscript.cs\u201d \u201cbuildscripts/deployscript.cs\u201d","title":"Build script runner"},{"location":"build-script-runner/#usage","text":".NET core usage: dotnet flubu {TargetToExecute} {Flubu options} {build script arguments} .NET core global tool usage: flubu {TargetToExecute} {Flubu options} {build script arguments} .NET usage: flubu.exe {TargetToExecute} {Flubu options} {build script arguments}","title":"Usage"},{"location":"build-script-runner/#multiple-target-execution","text":".NET core usage: dotnet flubu {TargetToExecute} {TargetToExecute2} {TargetToExecute3...} {Options} .NET usage: flubu.exe {TargetToExecute} {TargetToExecute2} {TargetToExecute3...} {Options} Target's can be executed in parallel with added -parallel option","title":"Multiple target execution"},{"location":"build-script-runner/#flubu-options","text":"","title":"Flubu options"},{"location":"build-script-runner/#target-help","text":"List all available targets: flubu help dotnet flubu help Target specific help: flubu {TargetName} help dotnet flubu {TargetName} help It displays all tasks with description that will be executed by target. It also displays which argument(with description) can be passed through to specific task in target.","title":"target help"},{"location":"build-script-runner/#default-build-script-locations","text":"\u201cBuildScript.cs\u201d \u201cDeployScript.cs\u201d \u201cBuildScript/BuildScript.cs\u201d \u201cbuildscript/deployscript.cs\u201d \u201cbuildscripts/buildscript.cs\u201d \u201cbuildscripts/deployscript.cs\u201d","title":"Default build script locations"},{"location":"buildscript-fundamentals/","text":"Build script \u00b6 Each build script should inherit from DefaulBuildScript class. Two abstact methods from DefaultBuildScript have to be implemented. ConfigureTargets: Here you can create new targets that will perform specific work. ConfigureBuildProperties: Here you can set various build properties which can be shared between multiple tasks and custom code. Empty build script example 1 2 3 4 5 6 7 8 9 10 public class BuildScript : DefaultBuildScript { protected override void ConfigureBuildProperties ( IBuildPropertiesContext context ) { } protected override void ConfigureTargets ( ITaskContext session ) { } } Targets \u00b6 Targets are used to perform specific work in a specific order. A target can for example execute flubu built in tasks like a task for compiling the solution or it can execute some custom code. Target can also have dependencies on other targets. Create a new Target \u00b6 Following code will create a new target that will execute a built in task. 1 2 3 4 5 6 protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Compile\" ) . SetDescription ( \"Compiles the solution\" ) . AddTask ( x => x . CompileSolutionTask ()); } Target's can also be defined with attributes on method. 1 2 3 4 5 6 7 [Target(\"targetName\", \"a\", \"b\")] [Target(\"targetName2\", \"c\", \"d\")] [Target(\"targetName3\", \"e\", \"f\")] public void Example ( ITarget target , string source , string destination ) { target . AddTask ( x => x . CopyFileTask ( source , destination , true )); } You can also pass values to parameter through console arguments or FlubuCore config file. Flubu targetName2 -destination=SomeOtherDestination Tasks \u00b6 Tasks are divided in tasks and core tasks. tasks can be executed in .net and .net core projects. Core tasks can only be executed in .net core projects. Following example executes 2 core tasks in a target. Order of execution is the same as specified in code. 1 2 3 context . CreateTarget ( \"Build\" ) . AddCoreTask ( x => x . Restore ()) . AddCoreTask ( x => x . Build ()); All Tasks have following methods: .OnError((c, ex) => { c.LogInfo(\"Example\");})) - onError can perform some custom action when error occurs on single task .Retry(5, 1000) - Retry mechanism. You can apply specific condition when retry mechanism will retry task. .Finally(c => { c.LogInfo(\"Example\");})) - Finally block acts just like finally in try catch .DoNotFailOnError() - script does not fail in case of exception. You can apply specific condition when task will not fail. .NoLog() - Task doesn't log anything to console output. .SetDescription() - Overrides the default help description of the task. .ForMember() - pass through console argument to method or property. See Pass console arguments, settings from json configuration file, environment variables with ForMember to tasks for more details. conditonal task execution with when cluase on single task (see bellow for group of tasks) 1 2 3 4 context . CreateTarget ( \"Example\" ) . AddTask ( x => x . CompileSolutionTask ()) . AddTask ( x => x . PublishNuGetPackageTask ( \"packageId\" , \"pathToNuspec\" )) . When ( c => c . BuildSystems (). Jenkins (). IsRunningOnJenkins ); set task parameters only when specified condition is meet. 1 2 3 4 5 6 7 8 9 10 var compile = context . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the VS solution\" ) . AddCoreTask ( x => x . Build (). Configuration ( \"Release\" ) . When ( () => { return context . BuildSystems (). IsLocalBuild ; }, task => { task . Configuration ( \"Debug\" ); })); .Interactive() - Interactively pass argument from console to specified task method / parameter. Custom c# code / tasks \u00b6 Following example executes some custom code. You can also use built in flubu tasks in custom code as shown in example. 1 2 3 4 5 6 7 8 9 10 11 12 protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . Do ( CustomCodeExample ); } private static void CustomCodeExample ( ITaskContext context ) { //// You can put any c# code here and use any .net libraries. Console . WriteLine ( \"Dummy custom code\" ); context . Tasks (). NUnitTaskForNunitV3 ( \"project name\" ). Execute ( context ); } You can also have parameters on methods: 1 2 3 4 5 6 7 8 9 10 11 protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . Do ( CustomCodeExample , \"some value\" , 1 ); } private static void CustomCodeExample ( ITaskContext context , string arg1 , int arg2 ) { Console . WriteLine ( \"Dummy custom code\" ); context . Tasks (). NUnitTaskForNunitV3 ( \"project name\" ). Execute ( context ); } Target dependencies \u00b6 Target can have dependencies on other targets. All dependenies will be executed before target in the specified order. When targetC is executed target\u2019s will execute in the following order: TargetB, TargetA, TargetC 1 2 3 var targetA = context . CreateTarget ( \"TargetA\" ); var targetB = context . CreateTarget ( \"TargetB\" ); var targetC = context . CreateTarget ( \"TargetC\" ). DependsOn ( targetB , targetA ); Add target to target \u00b6 Target can be executed within other target with AddTarget. Target is executed in the order it was added Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected override void ConfigureTargets ( ITaskContext context ) { var exampleB = context . CreateTarget ( \"TargetB\" ) . Do ( Something ); context . CreateTarget ( \"TargetA\" ) . AddCoreTask ( x => x . Build ()) . AddTarget ( exampleB ) . Do ( JustAnExample ); } public void JustAnExample ( ITaskContext context ) { ... } following execution order is taken when TargetA is executed Build task TargetB target JustAnExample method Reuse set of tasks in different targets \u00b6 Following example shows how to reuse set of tasks in different targets: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 protected override void ConfigureTargets ( ITaskContext session ) { session . CreateTarget ( \"deploy.local\" ). AddTasks ( Deploy , \"c:\\\\ExamplaApp\" ). SetAsDefault (); session . CreateTarget ( \"deploy.test\" ). AddTasks ( Deploy , \"d:\\\\ExamplaApp\" ); session . CreateTarget ( \"deploy.prod\" ). AddTasks ( Deploy , \"e:\\\\ExamplaApp\" ); } private void Deploy ( ITarget target , string deployPath ) { target . AddTask ( x => x . IisTasks (). CreateAppPoolTask ( \"Example app pool\" ). Mode ( CreateApplicationPoolMode . DoNothingIfExists )) . AddTask ( x => x . IisTasks (). ControlAppPoolTask ( \"Example app pool\" , ControlApplicationPoolAction . Stop ). DoNotFailOnError ()) . Do ( UnzipPackage ) . AddTask ( x => x . CopyDirectoryStructureTask ( @\"Packages\\ExampleApp\" , @\"C:\\ExampleApp\" , true ). Retry ( 20 , 5000 )) . Do ( CreateWebSite ) } Add tasks to target with a foreach loop \u00b6 Following example shows how to add multiple tasks to target with a foreach loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected override void ConfigureTargets ( ITaskContext context ) { var solution = context . Properties . Get < VSSolution >( BuildProps . Solution ); context . CreateTarget ( \"Pack\" ) . ForEach ( solution . Projects , ( item , target ) => { target . AddCoreTask ( x => x . Pack (). Project ( item . ProjectName )) . Do ( JustAnExample , item ); }); } private void JustAnExample ( ITaskContext context , VSProjectInfo vsProjectInfo ) { //// Do something. } Example will execute Pack task for each project in solution. Group tasks and apply When, OnError, Finally on them \u00b6 Conditonal task execution with When clause on group of tasks. 1 2 3 4 5 6 7 8 9 10 11 12 protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . AddCoreTask ( x => x . Build ()) . Group ( target => { target . AddCoreTask ( x => x . Pack ()); target . AddCoreTask ( x => x . NugetPush ( \"pathToPackage\" )); }, when : c => ! c . BuildSystems (). Jenkins (). IsRunningOnJenkins ); } Finally on group of tasks: onFinally acts just like finally in try/catch. 1 2 3 4 5 6 7 8 9 10 11 12 context . CreateTarget ( \"Example\" ) . AddCoreTask ( x => x . Build ()) . Group ( target => { target . AddCoreTask ( x => x . Pack ()); target . AddCoreTask ( x => x . NugetPush ( \"pathToPackage\" )); }, onFinally : c => { c . Tasks (). DeleteFilesTask ( \"pathToNupkg\" , \"*.*\" , true ). Execute ( c ); }); OnError on group of tasks: You can perform some custom action when error occures in any of tasks that are in group. 1 2 3 4 5 6 7 8 9 10 11 12 context . CreateTarget ( \"Example\" ) . AddCoreTask ( x => x . Build ()) . Group ( target => { target . AddCoreTask ( x => x . Pack ()); target . AddCoreTask ( x => x . NugetPush ( \"pathToPackage\" )); }, onError : ( c , error ) => { //// some custom action when error occures in any of the task in group. }); Async execution of tasks, customCode and dependencies \u00b6 Tasks can be executed asynchrounously with AddTaskAsync or AddCoreTaskAsync method. Custom code can be executed asynchrounosly with DoAsync method. Dependencies can be executed asynchrounosly with DependsOnAsync method. Following target executes 3 tasks asynchorunusly. 1 2 3 4 session . CreateTarget ( \"run.tests\" ) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName3\" )); Async and sync methods can also be mixed 1 2 3 4 5 6 session . CreateTarget ( \"async.example\" ) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . Do ( SomeCustomMethod ) . DoAsync ( SomeCustomAsyncMethod2 ) . DoAsync ( SomeCustomAsyncMethod3 ); The code above will first execute 2 nunit tasks asynchronously and wait for both tasks to finish. Then it will execute SomeCustomMethod synchrounosly. After it is finished code from SomeCustomAsyncMethod2 and SomeCustomAsyncMethod3 will be executed asynchronously. sequential logging in asynchronus executed tasks and targets \u00b6 Usually logs are not readable when executing more than 1 task asynchronously. That's why FlubuCore offers sequential logging in asynchronus tasks. You can enable them with .SequentialLogging(true) on target. It has to be placed before asynchronus tasks/target dependencies otherwise logs will not be sequential. 1 2 3 4 5 6 context . CreateTarget ( \"Test\" ) . SetAsDefault () . SequentialLogging ( true ) . AddCoreTaskAsync ( x => x . Pack ()) . AddCoreTaskAsync ( x => x . Pack ()) . DependsOnAsync ( test2 , test3 ); Target executed in parallel have sequential logging on by default. flubu target1 target2 --parallel Other features \u00b6 Target features \u00b6 SetAsDefault method: When applied to target that target is runned by default if no target is specified when running the script with runner. SetAsHidden method: When applied to target that target is not shown in help and it can only be run as other target dependecie. Must method: Condition in must will have to be meet otherwise target execution will fail before any task get executed. Context features \u00b6 GetEnviromentVariable method: Get's the enviroment variable by name context.GetEnvironmentVariable(\"someVariable\"); Log: context.LogInfo(\"Some Text2\", ConsoleColor.Blue); GetVsSolution: Get's solution and it's project information context.GetVsSolution(); Run any program or command in build script with RunProgramTask \u00b6 1 2 3 4 5 6 7 8 protected override void ConfigureTargets ( ITaskContext session ) { var runExternalProgramExample = session . CreateTarget ( \"run.libz\" ) . AddTask ( x => x . RunProgramTask ( @\"packages\\LibZ.Tool\\1.2.0\\tools\\libz.exe\" ) . WorkingFolder ( @\".\\src\" ) . WithArguments ( \"add\" ) . WithArguments ( \"--libz\" , \"Assemblies.libz\" )); } Linux Example: 1 2 3 4 5 6 7 protected override void ConfigureTargets ( ITaskContext session ) { var runExternalProgramExample = session . CreateTarget ( \"systemctl.example\" ) AddTask ( x => x . RunProgramTask ( @\"systemctl\" ) . WithArguments ( \"start\" ) . WithArguments ( \"nginx.service\" )); } Build properties \u00b6 You can define various build properties in ConfigureBuildProperties method to share them in different tasks and custom code. Following example show how to share nunit console path across various nunit targets/tasks. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 protected override void ConfigureBuildProperties ( IBuildPropertiesContext context ) { context . Properties . Set ( BuildProps . NUnitConsolePath , @\"packages\\NUnit.ConsoleRunner.3.6.0\\tools\\nunit3-console.exe\" ); } protected override void ConfigureTargets ( ITaskContext session ) { session . CreateTarget ( \"unit.tests1\" ) . SetDescription ( \"Runs unit tests\" ) . AddTask ( x => x . NUnitTaskForNunitV3 ( \"FlubuExample.Tests\" )); session . CreateTarget ( \"unit.tests1\" ) AddTask ( x => x . NUnitTaskForNunitV3 ( \"FlubuExample.Tests2\" )); } If nunit console path would not be set in build properties you would have to set it in each task separately. like so: 1 2 3 4 5 6 7 8 9 10 11 protected override void ConfigureTargets ( ITaskContext session ) { session . CreateTarget ( \"unit.tests1\" ) . SetDescription ( \"Runs unit tests\" ) . AddTask ( x => x . NUnitTaskForNunitV3 ( \"FlubuExample.Tests\" ) . NunitConsolePath ( @\"packages\\NUnit.ConsoleRunner.3.6.0\\tools\\nunit3-console.exe\" )); session . CreateTarget ( \"unit.tests1\" ) . AddTask ( x => x . NUnitTaskForNunitV3 ( \"FlubuExample.Tests2\" ). NunitConsolePath ( @\"packages\\NUnit.ConsoleRunner.3.6.0\\tools\\nunit3-console.exe\" )); } Predefined build properties \u00b6 Some build properties are already defined. You can access them through interface: context.Properties.Get(PredefinedBuildProperties.OsPlatform); Available predefined build properties: OsPlatform PathToDotnetExecutable UserProfileFolder OutputDir ProductRootDir All of them can be overriden. Pass command line arguments, settings from json configuration file or environment variables to your build script properties. \u00b6 You can pass command line arguments, settings from json configuration file or environment variables to your build script properties by adding FromArg attribute to property. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class SimpleScript : DefaultBuildScript { [FromArg(\"sn\", \"If true app is deployed on second node. Otherwise not.\")] public bool deployOnSecondNode { get ; set ; } protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Deploy.Exapmle\" ) . AddTask ( x => x . FlubuWebApiTasks (). GetTokenTask ( \"user\" , \"pass\" ). SetWebApiBaseUrl ( \"noade1Url\" )) . AddTask ( x => x . FlubuWebApiTasks (). UploadPackageTask ( \"packageDir\" , \"*.zip\" )) . AddTask ( x => x . FlubuWebApiTasks (). ExecuteScriptTask ( \"Deploy\" , \"DeployScript.cs\" )) . Group ( target => { target . AddTask ( x => x . FlubuWebApiTasks (). GetTokenTask ( \"user\" , \"pass\" ). SetWebApiBaseUrl ( \"noade2Url\" )) . AddTask ( x => x . FlubuWebApiTasks (). UploadPackageTask ( \"packageDir\" , \"*.zip\" )) . AddTask ( x => x . FlubuWebApiTasks (). ExecuteScriptTask ( \"Deploy\" , \"DeployScript.cs\" )); }, when : c => deployOnSecondNode ); } } First parameter in FromArg attribute is the argument key. Second is the help description of the property shown in flubu runner. You actually don't need to put attribute on property. If u dont then the key is the same as property name and help is not shown for property in build script runner. Property types that are supported: string, boolean, int, long, decimal, double, DateTime. Passing command line argument to build script property. \u00b6 Dotnet flubu Deploy.Example -sn=true Passing setting from json configuration file to build script property \u00b6 Create file FlubuSettings.json where Flubu runner is located. Add argument key and value to file in json format. For above example json file would look like this: 1 2 3 4 { \"sn\" : true , \"SomeOtherKey\" : \"SomeOtherValue\" } It's typical to have different configuration settings for different environments for example development, testing, and production. Just create different json files FlubuSettings.{Environment}.Json and set enviroment variable 'ASPNETCORE_ENVIRONMENT' on desired machine You can also create json configuration file by machine name FlubuSettings.{MachineName}.Json . If MachineName in file matches the machine name Flubu will automatically read settings from that file. Passing enviroment variable to build script property \u00b6 You can also set script arguments through environment variables. environment variables must have prefix flubu_ For above example you would add environment variable from windows command line with the following command: set flubu_sn=true Pass console arguments, settings from json configuration file, environment variables with ForMember to tasks. \u00b6 There is an alternative more sophisticated way to pass console arguments, settings and environment variables to tasks 1 2 3 4 5 6 protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"compile\" ) . AddTask ( x => x . CompileSolutionTask () . ForMember ( y => y . SolutionFileName ( \"someSolution.sln\" ), \"solution\" , \"The solution to build.\" )); } First parameter is the method or property argument that will be passed through. values set in method parameters are default values if argument is not specified when running the build script. Second parameter is the argument key. Third optional parameter is help that will be displayed in detailed target help. If parameter is not set then default generated help will be displayed. Dotnet flubu compile -solution=someothersolution.sln Build system providers \u00b6 You can acces various build, commit... information for various build systems (such as Jenkins, TeamCity, AppVeyor, Travis...) 1 2 3 4 5 protected override void ConfigureTargets ( ITaskContext context ) { bool isLocalBuild = context . BuildSystems (). IsLocalBuild ; var gitCommitId = context . BuildSystems (). Jenkins (). GitCommitId ; } Build events \u00b6 OnBuildFailed event: 1 2 3 4 5 6 public class BuildScript : DefaultBuildScript { protected override void OnBuildFailed ( ITaskSession session , Exception ex ) { } } before and after target execution events: 1 2 3 4 5 6 7 protected override void BeforeTargetExecution ( ITaskContext context ) { } protected override void AfterTargetExecution ( ITaskContext context ) { } before and after build execution events: 1 2 3 4 5 6 7 protected override void BeforeBuildExecution ( ITaskContext context ) { } protected override void AfterBuildExecution ( ITaskSession session ) { } Partial and base class in script \u00b6 Partial and base classes are loaded automatically if they are located in the same directory as buildscript. Otherwise they have to be added with Include attribute.","title":"Build script fundamentals"},{"location":"buildscript-fundamentals/#build-script","text":"Each build script should inherit from DefaulBuildScript class. Two abstact methods from DefaultBuildScript have to be implemented. ConfigureTargets: Here you can create new targets that will perform specific work. ConfigureBuildProperties: Here you can set various build properties which can be shared between multiple tasks and custom code. Empty build script example 1 2 3 4 5 6 7 8 9 10 public class BuildScript : DefaultBuildScript { protected override void ConfigureBuildProperties ( IBuildPropertiesContext context ) { } protected override void ConfigureTargets ( ITaskContext session ) { } }","title":"Build script"},{"location":"buildscript-fundamentals/#targets","text":"Targets are used to perform specific work in a specific order. A target can for example execute flubu built in tasks like a task for compiling the solution or it can execute some custom code. Target can also have dependencies on other targets.","title":"Targets"},{"location":"buildscript-fundamentals/#create-a-new-target","text":"Following code will create a new target that will execute a built in task. 1 2 3 4 5 6 protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Compile\" ) . SetDescription ( \"Compiles the solution\" ) . AddTask ( x => x . CompileSolutionTask ()); } Target's can also be defined with attributes on method. 1 2 3 4 5 6 7 [Target(\"targetName\", \"a\", \"b\")] [Target(\"targetName2\", \"c\", \"d\")] [Target(\"targetName3\", \"e\", \"f\")] public void Example ( ITarget target , string source , string destination ) { target . AddTask ( x => x . CopyFileTask ( source , destination , true )); } You can also pass values to parameter through console arguments or FlubuCore config file. Flubu targetName2 -destination=SomeOtherDestination","title":"Create a new Target"},{"location":"buildscript-fundamentals/#tasks","text":"Tasks are divided in tasks and core tasks. tasks can be executed in .net and .net core projects. Core tasks can only be executed in .net core projects. Following example executes 2 core tasks in a target. Order of execution is the same as specified in code. 1 2 3 context . CreateTarget ( \"Build\" ) . AddCoreTask ( x => x . Restore ()) . AddCoreTask ( x => x . Build ()); All Tasks have following methods: .OnError((c, ex) => { c.LogInfo(\"Example\");})) - onError can perform some custom action when error occurs on single task .Retry(5, 1000) - Retry mechanism. You can apply specific condition when retry mechanism will retry task. .Finally(c => { c.LogInfo(\"Example\");})) - Finally block acts just like finally in try catch .DoNotFailOnError() - script does not fail in case of exception. You can apply specific condition when task will not fail. .NoLog() - Task doesn't log anything to console output. .SetDescription() - Overrides the default help description of the task. .ForMember() - pass through console argument to method or property. See Pass console arguments, settings from json configuration file, environment variables with ForMember to tasks for more details. conditonal task execution with when cluase on single task (see bellow for group of tasks) 1 2 3 4 context . CreateTarget ( \"Example\" ) . AddTask ( x => x . CompileSolutionTask ()) . AddTask ( x => x . PublishNuGetPackageTask ( \"packageId\" , \"pathToNuspec\" )) . When ( c => c . BuildSystems (). Jenkins (). IsRunningOnJenkins ); set task parameters only when specified condition is meet. 1 2 3 4 5 6 7 8 9 10 var compile = context . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the VS solution\" ) . AddCoreTask ( x => x . Build (). Configuration ( \"Release\" ) . When ( () => { return context . BuildSystems (). IsLocalBuild ; }, task => { task . Configuration ( \"Debug\" ); })); .Interactive() - Interactively pass argument from console to specified task method / parameter.","title":"Tasks"},{"location":"buildscript-fundamentals/#custom-c-code-tasks","text":"Following example executes some custom code. You can also use built in flubu tasks in custom code as shown in example. 1 2 3 4 5 6 7 8 9 10 11 12 protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . Do ( CustomCodeExample ); } private static void CustomCodeExample ( ITaskContext context ) { //// You can put any c# code here and use any .net libraries. Console . WriteLine ( \"Dummy custom code\" ); context . Tasks (). NUnitTaskForNunitV3 ( \"project name\" ). Execute ( context ); } You can also have parameters on methods: 1 2 3 4 5 6 7 8 9 10 11 protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . Do ( CustomCodeExample , \"some value\" , 1 ); } private static void CustomCodeExample ( ITaskContext context , string arg1 , int arg2 ) { Console . WriteLine ( \"Dummy custom code\" ); context . Tasks (). NUnitTaskForNunitV3 ( \"project name\" ). Execute ( context ); }","title":"Custom c# code / tasks"},{"location":"buildscript-fundamentals/#target-dependencies","text":"Target can have dependencies on other targets. All dependenies will be executed before target in the specified order. When targetC is executed target\u2019s will execute in the following order: TargetB, TargetA, TargetC 1 2 3 var targetA = context . CreateTarget ( \"TargetA\" ); var targetB = context . CreateTarget ( \"TargetB\" ); var targetC = context . CreateTarget ( \"TargetC\" ). DependsOn ( targetB , targetA );","title":"Target dependencies"},{"location":"buildscript-fundamentals/#add-target-to-target","text":"Target can be executed within other target with AddTarget. Target is executed in the order it was added Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected override void ConfigureTargets ( ITaskContext context ) { var exampleB = context . CreateTarget ( \"TargetB\" ) . Do ( Something ); context . CreateTarget ( \"TargetA\" ) . AddCoreTask ( x => x . Build ()) . AddTarget ( exampleB ) . Do ( JustAnExample ); } public void JustAnExample ( ITaskContext context ) { ... } following execution order is taken when TargetA is executed Build task TargetB target JustAnExample method","title":"Add target to target"},{"location":"buildscript-fundamentals/#reuse-set-of-tasks-in-different-targets","text":"Following example shows how to reuse set of tasks in different targets: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 protected override void ConfigureTargets ( ITaskContext session ) { session . CreateTarget ( \"deploy.local\" ). AddTasks ( Deploy , \"c:\\\\ExamplaApp\" ). SetAsDefault (); session . CreateTarget ( \"deploy.test\" ). AddTasks ( Deploy , \"d:\\\\ExamplaApp\" ); session . CreateTarget ( \"deploy.prod\" ). AddTasks ( Deploy , \"e:\\\\ExamplaApp\" ); } private void Deploy ( ITarget target , string deployPath ) { target . AddTask ( x => x . IisTasks (). CreateAppPoolTask ( \"Example app pool\" ). Mode ( CreateApplicationPoolMode . DoNothingIfExists )) . AddTask ( x => x . IisTasks (). ControlAppPoolTask ( \"Example app pool\" , ControlApplicationPoolAction . Stop ). DoNotFailOnError ()) . Do ( UnzipPackage ) . AddTask ( x => x . CopyDirectoryStructureTask ( @\"Packages\\ExampleApp\" , @\"C:\\ExampleApp\" , true ). Retry ( 20 , 5000 )) . Do ( CreateWebSite ) }","title":"Reuse set of tasks in different targets"},{"location":"buildscript-fundamentals/#add-tasks-to-target-with-a-foreach-loop","text":"Following example shows how to add multiple tasks to target with a foreach loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected override void ConfigureTargets ( ITaskContext context ) { var solution = context . Properties . Get < VSSolution >( BuildProps . Solution ); context . CreateTarget ( \"Pack\" ) . ForEach ( solution . Projects , ( item , target ) => { target . AddCoreTask ( x => x . Pack (). Project ( item . ProjectName )) . Do ( JustAnExample , item ); }); } private void JustAnExample ( ITaskContext context , VSProjectInfo vsProjectInfo ) { //// Do something. } Example will execute Pack task for each project in solution.","title":"Add tasks to target with a foreach loop"},{"location":"buildscript-fundamentals/#group-tasks-and-apply-when-onerror-finally-on-them","text":"Conditonal task execution with When clause on group of tasks. 1 2 3 4 5 6 7 8 9 10 11 12 protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . AddCoreTask ( x => x . Build ()) . Group ( target => { target . AddCoreTask ( x => x . Pack ()); target . AddCoreTask ( x => x . NugetPush ( \"pathToPackage\" )); }, when : c => ! c . BuildSystems (). Jenkins (). IsRunningOnJenkins ); } Finally on group of tasks: onFinally acts just like finally in try/catch. 1 2 3 4 5 6 7 8 9 10 11 12 context . CreateTarget ( \"Example\" ) . AddCoreTask ( x => x . Build ()) . Group ( target => { target . AddCoreTask ( x => x . Pack ()); target . AddCoreTask ( x => x . NugetPush ( \"pathToPackage\" )); }, onFinally : c => { c . Tasks (). DeleteFilesTask ( \"pathToNupkg\" , \"*.*\" , true ). Execute ( c ); }); OnError on group of tasks: You can perform some custom action when error occures in any of tasks that are in group. 1 2 3 4 5 6 7 8 9 10 11 12 context . CreateTarget ( \"Example\" ) . AddCoreTask ( x => x . Build ()) . Group ( target => { target . AddCoreTask ( x => x . Pack ()); target . AddCoreTask ( x => x . NugetPush ( \"pathToPackage\" )); }, onError : ( c , error ) => { //// some custom action when error occures in any of the task in group. });","title":"Group tasks and apply When, OnError, Finally on them"},{"location":"buildscript-fundamentals/#async-execution-of-tasks-customcode-and-dependencies","text":"Tasks can be executed asynchrounously with AddTaskAsync or AddCoreTaskAsync method. Custom code can be executed asynchrounosly with DoAsync method. Dependencies can be executed asynchrounosly with DependsOnAsync method. Following target executes 3 tasks asynchorunusly. 1 2 3 4 session . CreateTarget ( \"run.tests\" ) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName3\" )); Async and sync methods can also be mixed 1 2 3 4 5 6 session . CreateTarget ( \"async.example\" ) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . Do ( SomeCustomMethod ) . DoAsync ( SomeCustomAsyncMethod2 ) . DoAsync ( SomeCustomAsyncMethod3 ); The code above will first execute 2 nunit tasks asynchronously and wait for both tasks to finish. Then it will execute SomeCustomMethod synchrounosly. After it is finished code from SomeCustomAsyncMethod2 and SomeCustomAsyncMethod3 will be executed asynchronously.","title":"Async execution of tasks, customCode and dependencies"},{"location":"buildscript-fundamentals/#sequential-logging-in-asynchronus-executed-tasks-and-targets","text":"Usually logs are not readable when executing more than 1 task asynchronously. That's why FlubuCore offers sequential logging in asynchronus tasks. You can enable them with .SequentialLogging(true) on target. It has to be placed before asynchronus tasks/target dependencies otherwise logs will not be sequential. 1 2 3 4 5 6 context . CreateTarget ( \"Test\" ) . SetAsDefault () . SequentialLogging ( true ) . AddCoreTaskAsync ( x => x . Pack ()) . AddCoreTaskAsync ( x => x . Pack ()) . DependsOnAsync ( test2 , test3 ); Target executed in parallel have sequential logging on by default. flubu target1 target2 --parallel","title":"sequential logging in asynchronus executed tasks and targets"},{"location":"buildscript-fundamentals/#other-features","text":"","title":"Other features"},{"location":"buildscript-fundamentals/#target-features","text":"SetAsDefault method: When applied to target that target is runned by default if no target is specified when running the script with runner. SetAsHidden method: When applied to target that target is not shown in help and it can only be run as other target dependecie. Must method: Condition in must will have to be meet otherwise target execution will fail before any task get executed.","title":"Target features"},{"location":"buildscript-fundamentals/#context-features","text":"GetEnviromentVariable method: Get's the enviroment variable by name context.GetEnvironmentVariable(\"someVariable\"); Log: context.LogInfo(\"Some Text2\", ConsoleColor.Blue); GetVsSolution: Get's solution and it's project information context.GetVsSolution();","title":"Context features"},{"location":"buildscript-fundamentals/#run-any-program-or-command-in-build-script-with-runprogramtask","text":"1 2 3 4 5 6 7 8 protected override void ConfigureTargets ( ITaskContext session ) { var runExternalProgramExample = session . CreateTarget ( \"run.libz\" ) . AddTask ( x => x . RunProgramTask ( @\"packages\\LibZ.Tool\\1.2.0\\tools\\libz.exe\" ) . WorkingFolder ( @\".\\src\" ) . WithArguments ( \"add\" ) . WithArguments ( \"--libz\" , \"Assemblies.libz\" )); } Linux Example: 1 2 3 4 5 6 7 protected override void ConfigureTargets ( ITaskContext session ) { var runExternalProgramExample = session . CreateTarget ( \"systemctl.example\" ) AddTask ( x => x . RunProgramTask ( @\"systemctl\" ) . WithArguments ( \"start\" ) . WithArguments ( \"nginx.service\" )); }","title":"Run any program or command in build script with RunProgramTask"},{"location":"buildscript-fundamentals/#build-properties","text":"You can define various build properties in ConfigureBuildProperties method to share them in different tasks and custom code. Following example show how to share nunit console path across various nunit targets/tasks. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 protected override void ConfigureBuildProperties ( IBuildPropertiesContext context ) { context . Properties . Set ( BuildProps . NUnitConsolePath , @\"packages\\NUnit.ConsoleRunner.3.6.0\\tools\\nunit3-console.exe\" ); } protected override void ConfigureTargets ( ITaskContext session ) { session . CreateTarget ( \"unit.tests1\" ) . SetDescription ( \"Runs unit tests\" ) . AddTask ( x => x . NUnitTaskForNunitV3 ( \"FlubuExample.Tests\" )); session . CreateTarget ( \"unit.tests1\" ) AddTask ( x => x . NUnitTaskForNunitV3 ( \"FlubuExample.Tests2\" )); } If nunit console path would not be set in build properties you would have to set it in each task separately. like so: 1 2 3 4 5 6 7 8 9 10 11 protected override void ConfigureTargets ( ITaskContext session ) { session . CreateTarget ( \"unit.tests1\" ) . SetDescription ( \"Runs unit tests\" ) . AddTask ( x => x . NUnitTaskForNunitV3 ( \"FlubuExample.Tests\" ) . NunitConsolePath ( @\"packages\\NUnit.ConsoleRunner.3.6.0\\tools\\nunit3-console.exe\" )); session . CreateTarget ( \"unit.tests1\" ) . AddTask ( x => x . NUnitTaskForNunitV3 ( \"FlubuExample.Tests2\" ). NunitConsolePath ( @\"packages\\NUnit.ConsoleRunner.3.6.0\\tools\\nunit3-console.exe\" )); }","title":"Build properties"},{"location":"buildscript-fundamentals/#predefined-build-properties","text":"Some build properties are already defined. You can access them through interface: context.Properties.Get(PredefinedBuildProperties.OsPlatform); Available predefined build properties: OsPlatform PathToDotnetExecutable UserProfileFolder OutputDir ProductRootDir All of them can be overriden.","title":"Predefined build properties"},{"location":"buildscript-fundamentals/#pass-command-line-arguments-settings-from-json-configuration-file-or-environment-variables-to-your-build-script-properties","text":"You can pass command line arguments, settings from json configuration file or environment variables to your build script properties by adding FromArg attribute to property. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class SimpleScript : DefaultBuildScript { [FromArg(\"sn\", \"If true app is deployed on second node. Otherwise not.\")] public bool deployOnSecondNode { get ; set ; } protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Deploy.Exapmle\" ) . AddTask ( x => x . FlubuWebApiTasks (). GetTokenTask ( \"user\" , \"pass\" ). SetWebApiBaseUrl ( \"noade1Url\" )) . AddTask ( x => x . FlubuWebApiTasks (). UploadPackageTask ( \"packageDir\" , \"*.zip\" )) . AddTask ( x => x . FlubuWebApiTasks (). ExecuteScriptTask ( \"Deploy\" , \"DeployScript.cs\" )) . Group ( target => { target . AddTask ( x => x . FlubuWebApiTasks (). GetTokenTask ( \"user\" , \"pass\" ). SetWebApiBaseUrl ( \"noade2Url\" )) . AddTask ( x => x . FlubuWebApiTasks (). UploadPackageTask ( \"packageDir\" , \"*.zip\" )) . AddTask ( x => x . FlubuWebApiTasks (). ExecuteScriptTask ( \"Deploy\" , \"DeployScript.cs\" )); }, when : c => deployOnSecondNode ); } } First parameter in FromArg attribute is the argument key. Second is the help description of the property shown in flubu runner. You actually don't need to put attribute on property. If u dont then the key is the same as property name and help is not shown for property in build script runner. Property types that are supported: string, boolean, int, long, decimal, double, DateTime.","title":"Pass command line arguments, settings from json configuration file or environment variables to your build script properties."},{"location":"buildscript-fundamentals/#passing-command-line-argument-to-build-script-property","text":"Dotnet flubu Deploy.Example -sn=true","title":"Passing command line argument to build script property."},{"location":"buildscript-fundamentals/#passing-setting-from-json-configuration-file-to-build-script-property","text":"Create file FlubuSettings.json where Flubu runner is located. Add argument key and value to file in json format. For above example json file would look like this: 1 2 3 4 { \"sn\" : true , \"SomeOtherKey\" : \"SomeOtherValue\" } It's typical to have different configuration settings for different environments for example development, testing, and production. Just create different json files FlubuSettings.{Environment}.Json and set enviroment variable 'ASPNETCORE_ENVIRONMENT' on desired machine You can also create json configuration file by machine name FlubuSettings.{MachineName}.Json . If MachineName in file matches the machine name Flubu will automatically read settings from that file.","title":"Passing setting from json configuration file to build script property"},{"location":"buildscript-fundamentals/#passing-enviroment-variable-to-build-script-property","text":"You can also set script arguments through environment variables. environment variables must have prefix flubu_ For above example you would add environment variable from windows command line with the following command: set flubu_sn=true","title":"Passing enviroment variable to build script property"},{"location":"buildscript-fundamentals/#pass-console-arguments-settings-from-json-configuration-file-environment-variables-with-formember-to-tasks","text":"There is an alternative more sophisticated way to pass console arguments, settings and environment variables to tasks 1 2 3 4 5 6 protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"compile\" ) . AddTask ( x => x . CompileSolutionTask () . ForMember ( y => y . SolutionFileName ( \"someSolution.sln\" ), \"solution\" , \"The solution to build.\" )); } First parameter is the method or property argument that will be passed through. values set in method parameters are default values if argument is not specified when running the build script. Second parameter is the argument key. Third optional parameter is help that will be displayed in detailed target help. If parameter is not set then default generated help will be displayed. Dotnet flubu compile -solution=someothersolution.sln","title":"Pass console arguments, settings from json configuration file, environment variables with ForMember to tasks."},{"location":"buildscript-fundamentals/#build-system-providers","text":"You can acces various build, commit... information for various build systems (such as Jenkins, TeamCity, AppVeyor, Travis...) 1 2 3 4 5 protected override void ConfigureTargets ( ITaskContext context ) { bool isLocalBuild = context . BuildSystems (). IsLocalBuild ; var gitCommitId = context . BuildSystems (). Jenkins (). GitCommitId ; }","title":"Build system providers"},{"location":"buildscript-fundamentals/#build-events","text":"OnBuildFailed event: 1 2 3 4 5 6 public class BuildScript : DefaultBuildScript { protected override void OnBuildFailed ( ITaskSession session , Exception ex ) { } } before and after target execution events: 1 2 3 4 5 6 7 protected override void BeforeTargetExecution ( ITaskContext context ) { } protected override void AfterTargetExecution ( ITaskContext context ) { } before and after build execution events: 1 2 3 4 5 6 7 protected override void BeforeBuildExecution ( ITaskContext context ) { } protected override void AfterBuildExecution ( ITaskSession session ) { }","title":"Build events"},{"location":"buildscript-fundamentals/#partial-and-base-class-in-script","text":"Partial and base classes are loaded automatically if they are located in the same directory as buildscript. Otherwise they have to be added with Include attribute.","title":"Partial and base class in script"},{"location":"getting-started/","text":"Getting started with FlubuCore \u00b6 Getting started .NET core \u00b6 Installation .NET core \u00b6 Add new project to solution e.g. BuildScript Add FlubuCore reference to project with NuGet Or Install with FlubuCore template \u00b6 In console navigate where your solution is located. Run dotnet new -i FlubuCore.Template Run dotnet new FlubuCore This will add BuildScript.csproj with FlubuCore references and FlubuCore script template Write and run your first build script in .NET core \u00b6 Add BuildScript.cs file to buildscript projetct and add following code. Following code adds compile target to flubu commands. Compile target compiles the solution. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class MyBuildScript : DefaultBuildScript { protected override void ConfigureBuildProperties ( IBuildPropertiesContext context ) { context . Properties . Set ( BuildProps . CompanyName , \"Flubu\" ); context . Properties . Set ( BuildProps . CompanyCopyright , \"Copyright (C) 2010-2016 Flubu\" ); context . Properties . Set ( BuildProps . ProductId , \"FlubuCoreExample\" ); context . Properties . Set ( BuildProps . ProductName , \"FlubuCoreExample\" ); } protected override void ConfigureTargets ( ITaskContext session ) { var compile = context . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the solution.\" ) . AddCoreTask ( x => x . Build ( \"FlubuExample.sln\" )); } } Run build script in .NET core with dotnet CLI tool \u00b6 Add dotnet-flubu as Dotnet tool to csproj or xproj(project.json). No need if u installed FlubuCore with template csproj: 1 2 3 <ItemGroup> <DotNetCliToolReference Include= \"dotnet-flubu\" Version= \"1.7.0\" /> </ItemGroup> project.json: 1 2 3 4 5 \"tools\" : { \"dotnet-flubu\" : { \"version\" : \"1.7.0\" } } Run dotnet restore . This command will restore dotnet-flubu package and add it to dotnet tool commands. Run dotnet flubu help . There you will see besided default commands the compile command that we just added. Run dotnet flubu compile This command will compile your solution. Run build script in .NET core with global tool \u00b6 .net core sdk 2.1.300 or greater must be installed. Install FlubuCore global tool: dotnet tool install --global FlubuCore.GlobalTool Run flubu compile where build script is located. It will compile your solution. This is very basic build script just for you to see how simple it is to get you started. FlubuCore has to offer a lot of nice features. Read more about them at Build script fundamentals alternatively you can take a look at .net core examples and see most of main features in action. Getting started .NET \u00b6 Requirements .NET \u00b6 Build script project where FlubuCore is referenced must target .NET framework 4.62 or greater. If this is not possible you can use Flubu version 2.64 or less which only requires .NET Framework 4.0. To run build script with FlubuCore runner .net runtime 4.0 or greater is required. Installation .NET \u00b6 Add new project to solution e.g. BuildScript Add FlubuCore.Runner reference to project with nuGet. This will add reference To FlubuCore.dll, add BuildScript.cs (build script template) to project and it will also add flubu.exe for running the buildscript. Write and run your first build script in .NET \u00b6 Modify BuildScript.cs with the following code. Change solution name to yours. Following code adds compile target to flubu commands. Compile target compiles the solution. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using FlubuCore.Context ; using FlubuCore.Scripting ; public class BuildScript : DefaultBuildScript { protected override void ConfigureBuildProperties ( IBuildPropertiesContext context ) { context . Properties . Set ( BuildProps . ProductId , \"FlubuExample\" ); context . Properties . Set ( BuildProps . ProductName , \"FlubuExample\" ); context . Properties . Set ( BuildProps . SolutionFileName , \"FlubuExample.sln\" ); context . Properties . Set ( BuildProps . BuildConfiguration , \"Release\" ); } protected override void ConfigureTargets ( ITaskContext session ) { var compile = session . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the solution.\" ) . AddTask ( x => x . CompileSolutionTask ()); } } Run build script \u00b6 Open cmd and navigate to buildscript project directory. Run flubu.exe help. There you will see besides default commands the compile command that we just added. Run flubu.exe compile. It will compile your solution. This is very basic build script just for you to see how simple it is to get you started. FlubuCore has to offer a lot of nice features. Read more about them at Build script fundamentals alternatively you can take a look at .net examples and see most of main features in action.","title":"Getting started"},{"location":"getting-started/#getting-started-with-flubucore","text":"","title":"Getting started with FlubuCore"},{"location":"getting-started/#getting-started-net-core","text":"","title":"Getting started .NET core"},{"location":"getting-started/#installation-net-core","text":"Add new project to solution e.g. BuildScript Add FlubuCore reference to project with NuGet","title":"Installation .NET core"},{"location":"getting-started/#or-install-with-flubucore-template","text":"In console navigate where your solution is located. Run dotnet new -i FlubuCore.Template Run dotnet new FlubuCore This will add BuildScript.csproj with FlubuCore references and FlubuCore script template","title":"Or Install with FlubuCore template"},{"location":"getting-started/#write-and-run-your-first-build-script-in-net-core","text":"Add BuildScript.cs file to buildscript projetct and add following code. Following code adds compile target to flubu commands. Compile target compiles the solution. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class MyBuildScript : DefaultBuildScript { protected override void ConfigureBuildProperties ( IBuildPropertiesContext context ) { context . Properties . Set ( BuildProps . CompanyName , \"Flubu\" ); context . Properties . Set ( BuildProps . CompanyCopyright , \"Copyright (C) 2010-2016 Flubu\" ); context . Properties . Set ( BuildProps . ProductId , \"FlubuCoreExample\" ); context . Properties . Set ( BuildProps . ProductName , \"FlubuCoreExample\" ); } protected override void ConfigureTargets ( ITaskContext session ) { var compile = context . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the solution.\" ) . AddCoreTask ( x => x . Build ( \"FlubuExample.sln\" )); } }","title":"Write and run your first build script in .NET core"},{"location":"getting-started/#run-build-script-in-net-core-with-dotnet-cli-tool","text":"Add dotnet-flubu as Dotnet tool to csproj or xproj(project.json). No need if u installed FlubuCore with template csproj: 1 2 3 <ItemGroup> <DotNetCliToolReference Include= \"dotnet-flubu\" Version= \"1.7.0\" /> </ItemGroup> project.json: 1 2 3 4 5 \"tools\" : { \"dotnet-flubu\" : { \"version\" : \"1.7.0\" } } Run dotnet restore . This command will restore dotnet-flubu package and add it to dotnet tool commands. Run dotnet flubu help . There you will see besided default commands the compile command that we just added. Run dotnet flubu compile This command will compile your solution.","title":"Run build script in .NET core with dotnet CLI tool"},{"location":"getting-started/#run-build-script-in-net-core-with-global-tool","text":".net core sdk 2.1.300 or greater must be installed. Install FlubuCore global tool: dotnet tool install --global FlubuCore.GlobalTool Run flubu compile where build script is located. It will compile your solution. This is very basic build script just for you to see how simple it is to get you started. FlubuCore has to offer a lot of nice features. Read more about them at Build script fundamentals alternatively you can take a look at .net core examples and see most of main features in action.","title":"Run build script in .NET core with global tool"},{"location":"getting-started/#getting-started-net","text":"","title":"Getting started .NET"},{"location":"getting-started/#requirements-net","text":"Build script project where FlubuCore is referenced must target .NET framework 4.62 or greater. If this is not possible you can use Flubu version 2.64 or less which only requires .NET Framework 4.0. To run build script with FlubuCore runner .net runtime 4.0 or greater is required.","title":"Requirements .NET"},{"location":"getting-started/#installation-net","text":"Add new project to solution e.g. BuildScript Add FlubuCore.Runner reference to project with nuGet. This will add reference To FlubuCore.dll, add BuildScript.cs (build script template) to project and it will also add flubu.exe for running the buildscript.","title":"Installation .NET"},{"location":"getting-started/#write-and-run-your-first-build-script-in-net","text":"Modify BuildScript.cs with the following code. Change solution name to yours. Following code adds compile target to flubu commands. Compile target compiles the solution. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using FlubuCore.Context ; using FlubuCore.Scripting ; public class BuildScript : DefaultBuildScript { protected override void ConfigureBuildProperties ( IBuildPropertiesContext context ) { context . Properties . Set ( BuildProps . ProductId , \"FlubuExample\" ); context . Properties . Set ( BuildProps . ProductName , \"FlubuExample\" ); context . Properties . Set ( BuildProps . SolutionFileName , \"FlubuExample.sln\" ); context . Properties . Set ( BuildProps . BuildConfiguration , \"Release\" ); } protected override void ConfigureTargets ( ITaskContext session ) { var compile = session . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the solution.\" ) . AddTask ( x => x . CompileSolutionTask ()); } }","title":"Write and run your first build script in .NET"},{"location":"getting-started/#run-build-script","text":"Open cmd and navigate to buildscript project directory. Run flubu.exe help. There you will see besides default commands the compile command that we just added. Run flubu.exe compile. It will compile your solution. This is very basic build script just for you to see how simple it is to get you started. FlubuCore has to offer a lot of nice features. Read more about them at Build script fundamentals alternatively you can take a look at .net examples and see most of main features in action.","title":"Run build script"},{"location":"override-add-options/","text":"FlubuCore offers you to add or override options in tasks that run external processes. Let's say you have target 1 2 context . CreateTarget ( \"Example\" ) ` . AddCoreTask ( x => x . Build ( \"MySolution.sln\" ). Configuration ( \"Release\" ); and you wan't to build solution in debug configuration. You could just write in console flubu example --configuration=Debug flubu would execute dotnet build MySolution.sln --configuration Debug Note option keys are the same as in external processes. short versions of options keys also work. So in above example -c=debug would also work. Tab completion for all external process options also work in Interactive mode Tasks in FlubuCore plugins that does not support overriding of options out of the box can still be overriden with special prefix before option key /o: /o:{external_process_option={value} With /o: FlubuCore adds specified option to all tasks in target's which can be a problem if target execute multiple tasks. So instead of /o: you can use prefix by task name /{taskName}:{external_process_option}={value} Alternatively you can change default prefix on task 1 2 3 context . CreateTarget ( \"Publish\" ) AddCoreTask ( x => x . Publish () . ChangeDefaultAdditionalOptionPrefix ( \"/p:\" )); Example \u00b6 Build task does support overriding of options out of the box but for the simplicity of the example build task is used. 1 2 context . CreateTarget ( \"Example\" ) ` . AddCoreTask ( x => x . Build ( \"MySolution.sln\" ). Configuration ( \"Release\" ); and you wan't to build solution in debug configuration. You could just write in console flubu example /o:configuration=Debug or flubu example /o:c=Debug or flubu example /build:c=Debug flubu would execute dotnet build MySolution.sln -c Debug","title":"Override existing options or add additional options to tasks through console"},{"location":"override-add-options/#example","text":"Build task does support overriding of options out of the box but for the simplicity of the example build task is used. 1 2 context . CreateTarget ( \"Example\" ) ` . AddCoreTask ( x => x . Build ( \"MySolution.sln\" ). Configuration ( \"Release\" ); and you wan't to build solution in debug configuration. You could just write in console flubu example /o:configuration=Debug or flubu example /o:c=Debug or flubu example /build:c=Debug flubu would execute dotnet build MySolution.sln -c Debug","title":"Example"},{"location":"referencing-external-assemblies/","text":"Referencing external assemblies in build script \u00b6 FlubuCore loads all assemblies references and nuget packages automatically from build script csproj. Csproj must be at on of the location specified here If not assembly and nuget references will not be loaded automatically when executing script. Note You can also disable referencing assemblies and nuget packages from build script by adding attribute to build script. 1 2 3 4 [DisableLoadScriptReferencesAutomatically] public class BuildScript : DefaultBuildScript { } Alternatively when you are running scripts without csproj(for example deploy scripts) external references can be added with directives in three ways: By assembly relative or full path \u00b6 On the build script class you have to add attribute: 1 2 3 4 5 6 7 8 [Assembly(@\".\\packages\\Newtonsoft.Json.9.0.1\\lib\\net45\\Newtonsoft.Json.dll\")] public class BuildScript : DefaultBuildScript { public void ReferencedAssemlby ( ITaskContext context ) { JsonConvert . SerializeObject ( \"Example\" ); } } FlubuCore can also load all assemblies from specified directory and optionaly from it's subdirectories 1 2 3 4 [AssemblyFromDirectory(@\".\\Packages\", true)] public class BuildScript : DefaultBuildScript { } Referencing nuget packages \u00b6 Flubu supports referencing nuget packages. .net core sdk or msbuild must be installed if u want to reference nuget packages otherwise they will not get restored. You have to add NugetPackage attribute on the script class: 1 2 3 4 5 6 7 8 [NugetPackage(\"Newtonsoftjson\", \"11.0.2\")] public class BuildScript : DefaultBuildScript { public void ReferencedNugetPackage ( ITaskContext context ) { JsonConvert . SerializeObject ( \"Example\" ); } } Load assembly by assembly full name \u00b6 System assemblies can be loaded by fully qualifed assemlby name. You have to add Reference attribute on the script class: 1 2 3 4 5 6 7 8 [Reference(\"System.Xml.XmlDocument, System.Xml, Version=4.0.0.0, Culture=neutral, publicKeyToken=b77a5c561934e089\")] public class BuildScript : DefaultBuildScript { public void ReferencedAssemlby ( ITaskContext context ) { XmlDocument xml = new XmlDocument (); } } One way to get fully qualifed assembly name: 1 var fullQualifedAssemblyName = typeof(XmlDocument).Assembly.FullName; Load all assemblies from directory \u00b6 Even if you are not using your script together with csproj flubu can load all external assemblies for you automatically from directory (assemblies in subdirectories are also loaded ). By default flubu loads all assemblies from directory FlubuLib. Just create the directory at the flubu runner location and put assemblies in that directory. You can specify directory in flubu runner from where to load assemblyes also: flubu.exe -ass=somedirectory dotnet flubu -ass=somedirectory alternatively you can put ass key into flubusettings.json file: 1 2 3 4 { \"ass\" : \"someDirectory\", \"SomeOtherKey\" : \"SomeOtherValue\" }` Adding other .cs files to script \u00b6 Other .cs files have to be added through attribute they are not automatically loaded from buildscript project file. Exception are build script base classes and partial classes they are loaded automatically. 1 2 3 4 5 6 7 8 [Include(@\".\\BuildHelper.cs\")] public class BuildScript : DefaultBuildScript { public void Example ( ITaskContext context ) { BuildHelper . SomeMethod (); } } FlubuCore can also load all .cs files to script from specified directory and optionaly from it's subfolders. 1 2 3 4 [IncludeFromDirectory(@\".\\Helpers\", true)] public class BuildScript : DefaultBuildScript { }","title":"Referencing external assemblies in build script"},{"location":"referencing-external-assemblies/#referencing-external-assemblies-in-build-script","text":"FlubuCore loads all assemblies references and nuget packages automatically from build script csproj. Csproj must be at on of the location specified here If not assembly and nuget references will not be loaded automatically when executing script. Note You can also disable referencing assemblies and nuget packages from build script by adding attribute to build script. 1 2 3 4 [DisableLoadScriptReferencesAutomatically] public class BuildScript : DefaultBuildScript { } Alternatively when you are running scripts without csproj(for example deploy scripts) external references can be added with directives in three ways:","title":"Referencing external assemblies in build script"},{"location":"referencing-external-assemblies/#by-assembly-relative-or-full-path","text":"On the build script class you have to add attribute: 1 2 3 4 5 6 7 8 [Assembly(@\".\\packages\\Newtonsoft.Json.9.0.1\\lib\\net45\\Newtonsoft.Json.dll\")] public class BuildScript : DefaultBuildScript { public void ReferencedAssemlby ( ITaskContext context ) { JsonConvert . SerializeObject ( \"Example\" ); } } FlubuCore can also load all assemblies from specified directory and optionaly from it's subdirectories 1 2 3 4 [AssemblyFromDirectory(@\".\\Packages\", true)] public class BuildScript : DefaultBuildScript { }","title":"By assembly relative or full path"},{"location":"referencing-external-assemblies/#referencing-nuget-packages","text":"Flubu supports referencing nuget packages. .net core sdk or msbuild must be installed if u want to reference nuget packages otherwise they will not get restored. You have to add NugetPackage attribute on the script class: 1 2 3 4 5 6 7 8 [NugetPackage(\"Newtonsoftjson\", \"11.0.2\")] public class BuildScript : DefaultBuildScript { public void ReferencedNugetPackage ( ITaskContext context ) { JsonConvert . SerializeObject ( \"Example\" ); } }","title":"Referencing nuget packages"},{"location":"referencing-external-assemblies/#load-assembly-by-assembly-full-name","text":"System assemblies can be loaded by fully qualifed assemlby name. You have to add Reference attribute on the script class: 1 2 3 4 5 6 7 8 [Reference(\"System.Xml.XmlDocument, System.Xml, Version=4.0.0.0, Culture=neutral, publicKeyToken=b77a5c561934e089\")] public class BuildScript : DefaultBuildScript { public void ReferencedAssemlby ( ITaskContext context ) { XmlDocument xml = new XmlDocument (); } } One way to get fully qualifed assembly name: 1 var fullQualifedAssemblyName = typeof(XmlDocument).Assembly.FullName;","title":"Load assembly by assembly full name"},{"location":"referencing-external-assemblies/#load-all-assemblies-from-directory","text":"Even if you are not using your script together with csproj flubu can load all external assemblies for you automatically from directory (assemblies in subdirectories are also loaded ). By default flubu loads all assemblies from directory FlubuLib. Just create the directory at the flubu runner location and put assemblies in that directory. You can specify directory in flubu runner from where to load assemblyes also: flubu.exe -ass=somedirectory dotnet flubu -ass=somedirectory alternatively you can put ass key into flubusettings.json file: 1 2 3 4 { \"ass\" : \"someDirectory\", \"SomeOtherKey\" : \"SomeOtherValue\" }`","title":"Load all assemblies from directory"},{"location":"referencing-external-assemblies/#adding-other-cs-files-to-script","text":"Other .cs files have to be added through attribute they are not automatically loaded from buildscript project file. Exception are build script base classes and partial classes they are loaded automatically. 1 2 3 4 5 6 7 8 [Include(@\".\\BuildHelper.cs\")] public class BuildScript : DefaultBuildScript { public void Example ( ITaskContext context ) { BuildHelper . SomeMethod (); } } FlubuCore can also load all .cs files to script from specified directory and optionaly from it's subfolders. 1 2 3 4 [IncludeFromDirectory(@\".\\Helpers\", true)] public class BuildScript : DefaultBuildScript { }","title":"Adding other .cs files to script"},{"location":"tasks/","text":"Here you can find list of FlubuCore built in tasks with short description. Each task have fluent interface. See code documentation for detailed task documentation. If u have any questions about a task join us on gitter. Tasks \u00b6 Task name Description RunProgramTask Task runs specified external program CompileSolutionTask Task compiles specified solution. PackageTask Task Packages specified directories and files into specified directory or zip file.. FetchBuildVersionFromFileTask Task fetches build version from file. GitVersionTask GitVersion is a tool to help you achieve Semantic Versioning on your project. [[ Documentation FetchVersionFromExternalSourceTask Task fetches build version from external source(Appveyor, travis, jenkins...). GenerateCommonAssemlbyInfoTask Task generates common assembly info for solution NUnitTask Task runs nunit tests with nunit.exe runner XunitTask Task runs xunit tests with xunit.exe runner NUnitWithDotCoverTaskTask runs nunit tests in combination with dotCover test coverage analysis PublishNugetPackageTask Task publishes nuget package to specified nuget server NugetCmdLineTask Manipulate nugets with nuget.exe UpdateXmlFileTask Updates an XML file using the specified update commands. UpdateJsonFileTask Task updates an JSON file using the specified update commands. CleanoutputTask Task clean all projects outputs in solution. ControlServiceTask Control windows service with sc.exe command. CreateWindowsServiceTask Creates windows service with sc.exe command. ExecutePowerShellScriptTask Executes specified power shell script. SqlCmdTask Execute SQL script files with sqlcmd.exe CreateAppPoolTask Task creates new application pool in iis. ControlAppPoolTask Task can start/stop application pool. DeleteAppPoolTask Task deletes specified application pool. CreateWebApplicationTask Task creates new web application for specified web site in iis. CreateWebSiteTask Task creates new web site in iis. AddWebSiteBindingTask Task compiles specified solution. GetLocalIisVersionTask Task gets the version on iis on local machine. ReplaceTokenTask Task Replaces specified tokens in file. ReplaceTextTask Task Replaces specified texts in file. CopyDirectoryStructureTask Task copies files from one directory to another with specified filters. CopyFileTask Task copies file from from one directory to another. CopyDirectoryStructureTask Copies a directory tree from the source to the destination.. CreateDirectoryTask Task creates directory at specified location. DeleteDirectoryTask Task deletes specified directory. DeleteFilesTask Task delete files from specified directory matching specified pattern. UnzipFileTask Task unzips specified zip file to specified location. ZipFileTask Task zips specified files. OpenCoverTask Task runs open cover tool. OpenCoverToCoberturaTask Task runs open cover to cobertuta tool. CoverageReportTask Task runs the coverage report generator tool. LoadSolutionTask Task load's solution information to the flubu session. T4TemplateTask Generate T4 template with TextTransform.exe utility.. GitTasks Git Clone, Add, Commit, Pull, Push, Tag, RemoveFiles tasks. DockerTasks Build, Run, Stop Remove Container, Remove Image and all other tasks for coresponding docker cli commands. All tasks are genereated from offical docker documentation. FlubuWebApiTasks Various flubu web api client tasks. .net core Tasks \u00b6 Task name Description ExecuteDotnetTask Executes specified dotnet command. DotnetRestoreTask Restores the dependencies and tools for a given application / project.. DotnetPublishTask compiles the application, reads through its dependencies specified in the project file and publishes the resulting set of files to a directory. DotnetBuildTask Builds a project and all of its dependencies. DotnetPackTask command builds the project and creates NuGet packages. The result of this command is a NuGet package. DotnetNugetPushTask Pushes the nuget package to the nuget server. DotnetTestTask Runs tests using a test runner specified in the project.json / csproj. DotnetCleanTask Cleans the output of a project. DotnetEfTasks Various entity framework tasks. UpdateNetCoreVersionTask Updates the version in csproj / project.json file CoverletTask Coverlet is a cross platform code coverage library for .NET Core, with support for line, branch and method coverage [[ Documentation SshComandLinuxTask Runs specified command on the remote host. SshCopyLinuxTask Copy projects/files to the remote host. SystemCtlLinuxTask Runs system ctl.","title":"Tasks"},{"location":"tasks/#tasks","text":"Task name Description RunProgramTask Task runs specified external program CompileSolutionTask Task compiles specified solution. PackageTask Task Packages specified directories and files into specified directory or zip file.. FetchBuildVersionFromFileTask Task fetches build version from file. GitVersionTask GitVersion is a tool to help you achieve Semantic Versioning on your project. [[ Documentation FetchVersionFromExternalSourceTask Task fetches build version from external source(Appveyor, travis, jenkins...). GenerateCommonAssemlbyInfoTask Task generates common assembly info for solution NUnitTask Task runs nunit tests with nunit.exe runner XunitTask Task runs xunit tests with xunit.exe runner NUnitWithDotCoverTaskTask runs nunit tests in combination with dotCover test coverage analysis PublishNugetPackageTask Task publishes nuget package to specified nuget server NugetCmdLineTask Manipulate nugets with nuget.exe UpdateXmlFileTask Updates an XML file using the specified update commands. UpdateJsonFileTask Task updates an JSON file using the specified update commands. CleanoutputTask Task clean all projects outputs in solution. ControlServiceTask Control windows service with sc.exe command. CreateWindowsServiceTask Creates windows service with sc.exe command. ExecutePowerShellScriptTask Executes specified power shell script. SqlCmdTask Execute SQL script files with sqlcmd.exe CreateAppPoolTask Task creates new application pool in iis. ControlAppPoolTask Task can start/stop application pool. DeleteAppPoolTask Task deletes specified application pool. CreateWebApplicationTask Task creates new web application for specified web site in iis. CreateWebSiteTask Task creates new web site in iis. AddWebSiteBindingTask Task compiles specified solution. GetLocalIisVersionTask Task gets the version on iis on local machine. ReplaceTokenTask Task Replaces specified tokens in file. ReplaceTextTask Task Replaces specified texts in file. CopyDirectoryStructureTask Task copies files from one directory to another with specified filters. CopyFileTask Task copies file from from one directory to another. CopyDirectoryStructureTask Copies a directory tree from the source to the destination.. CreateDirectoryTask Task creates directory at specified location. DeleteDirectoryTask Task deletes specified directory. DeleteFilesTask Task delete files from specified directory matching specified pattern. UnzipFileTask Task unzips specified zip file to specified location. ZipFileTask Task zips specified files. OpenCoverTask Task runs open cover tool. OpenCoverToCoberturaTask Task runs open cover to cobertuta tool. CoverageReportTask Task runs the coverage report generator tool. LoadSolutionTask Task load's solution information to the flubu session. T4TemplateTask Generate T4 template with TextTransform.exe utility.. GitTasks Git Clone, Add, Commit, Pull, Push, Tag, RemoveFiles tasks. DockerTasks Build, Run, Stop Remove Container, Remove Image and all other tasks for coresponding docker cli commands. All tasks are genereated from offical docker documentation. FlubuWebApiTasks Various flubu web api client tasks.","title":"Tasks"},{"location":"tasks/#net-core-tasks","text":"Task name Description ExecuteDotnetTask Executes specified dotnet command. DotnetRestoreTask Restores the dependencies and tools for a given application / project.. DotnetPublishTask compiles the application, reads through its dependencies specified in the project file and publishes the resulting set of files to a directory. DotnetBuildTask Builds a project and all of its dependencies. DotnetPackTask command builds the project and creates NuGet packages. The result of this command is a NuGet package. DotnetNugetPushTask Pushes the nuget package to the nuget server. DotnetTestTask Runs tests using a test runner specified in the project.json / csproj. DotnetCleanTask Cleans the output of a project. DotnetEfTasks Various entity framework tasks. UpdateNetCoreVersionTask Updates the version in csproj / project.json file CoverletTask Coverlet is a cross platform code coverage library for .NET Core, with support for line, branch and method coverage [[ Documentation SshComandLinuxTask Runs specified command on the remote host. SshCopyLinuxTask Copy projects/files to the remote host. SystemCtlLinuxTask Runs system ctl.","title":".net core Tasks"},{"location":"write-plugins/","text":"You can write your own tasks for flubu and extend flubu fluent interface with them. When fluent interface will be extended with your custom task you could simply add it to the target or execute it with Do task with the following example code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class BuildScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"FlubuPlugin.Example\" ) . SetAsDefault () . Do ( DoPluginExample ); context . CreateTarget ( \"FlubuPlugin.Example2\" ) . AddTask ( x => x . ExampleFlubuPluginTask ()); } private void DoPluginExample ( ITaskContext context ) { context . Tasks (). ExampleFlubuPluginTask () . Message ( \"some example message from plugin\" ). Execute ( context ); } } How to create your own task plugin \u00b6 Create new project in vs FlubuCore.{PluginName} Add FlubuCore nuget package to project. Add task and implement it. Following code shows implementation of example flubu plugin task. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ExampleFlubuPluginTask : TaskBase < int , ExampleFlubuPluginTask > { private string _message ; protected override string Description { get ; set ; } public ExampleFlubuPluginTask Message ( string message ) { _message = message ; return this ; } protected override int DoExecute ( ITaskContextInternal context ) { //// write task logic here. context . LogInfo (! string . IsNullOrEmpty ( _message ) ? _message : \"Just some dummy code\" ); return 0 ; } } Then you need to write an extension method to add the task to flubu fluent interface. Extension method for our example task: 1 2 3 4 5 6 7 8 9 10 11 12 using FlubuCore.PluginExample ; namespace FlubuCore.Context.FluentInterface.Interfaces { public static class TaskFluentInterfaceExtension { public static ExampleFlubuPluginTask ExampleFlubuPluginTask ( this ITaskFluentInterface flubu ) { return new ExampleFlubuPluginTask (); } } } It is recommended that you add task to ICoreTaskFluentInterface or ITaskFluentInterface We would be very glad if you add your plugin to the nuget repository. It would be great if the plugin name would start with FlubuCore so others can find it. you can see whole example plugin code here","title":"How to write and use plugins"},{"location":"write-plugins/#how-to-create-your-own-task-plugin","text":"Create new project in vs FlubuCore.{PluginName} Add FlubuCore nuget package to project. Add task and implement it. Following code shows implementation of example flubu plugin task. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ExampleFlubuPluginTask : TaskBase < int , ExampleFlubuPluginTask > { private string _message ; protected override string Description { get ; set ; } public ExampleFlubuPluginTask Message ( string message ) { _message = message ; return this ; } protected override int DoExecute ( ITaskContextInternal context ) { //// write task logic here. context . LogInfo (! string . IsNullOrEmpty ( _message ) ? _message : \"Just some dummy code\" ); return 0 ; } } Then you need to write an extension method to add the task to flubu fluent interface. Extension method for our example task: 1 2 3 4 5 6 7 8 9 10 11 12 using FlubuCore.PluginExample ; namespace FlubuCore.Context.FluentInterface.Interfaces { public static class TaskFluentInterfaceExtension { public static ExampleFlubuPluginTask ExampleFlubuPluginTask ( this ITaskFluentInterface flubu ) { return new ExampleFlubuPluginTask (); } } } It is recommended that you add task to ICoreTaskFluentInterface or ITaskFluentInterface We would be very glad if you add your plugin to the nuget repository. It would be great if the plugin name would start with FlubuCore so others can find it. you can see whole example plugin code here","title":"How to create your own task plugin"},{"location":"AwesomePlugins/awesome-plugins/","text":"FlubuCore.CakePlugin - Cake have quite alot of useful addins. This plugin allows you to use any Cake addins in FlubuCore. FlubuCore.Azure - Plugin adds over 2000 generated tasks for Azure CLI commands. Tasks are generated from offical documentation. FlubuCore.Diff - Plugin adds Diff task to FlubuCore task fluent interface. Diff task compares 2 specified files and generates html report with differences. FlubuCore.Gitter - Plugin for sending gitter messages in specified room. FlubuCore.Kubernetes - Will not be implemented. Use Kurernetes client with FlubuCore instead. FlubuCore.Npm - Plugin adds tasks for numerous npm CLI commands. FlubuCore.Octopus - Plugin adds tasks for numerous octopus CLI commands. FlubuCore.Slack - Plugin for sending message to slack channels. FlubuCore.Chocolatey - Plugin adds tasks for numerous Chocolatey CLI commands. Chocolatey is a software management solution unlike anything else you've ever experienced on Windows. It focuses on simplicity, security, and scalability. You write a software deployment in PowerShell once for any software (not just installers), then you can deploy it everywhere you have Windows with any solution that can manage systems (configuration management, endpoint management, etc) and track and manage updates of that software over time.","title":"Plugins"},{"location":"WebApi/getting-started/","text":"About \u00b6 With FlubuCore web api you can execute FlubuCore scripts remotely. Mainly it is meant to automate deployment of .net or .net core applications from your build server to different environments but it can be used for any other FlubuCore script execution. Web Api supports: Executing flubu scripts on the server where web api is deployed. Uploading (deploy or any other) packages to the server where web api is deployed. Deleting packages from server where web api is deployed. Sending reports back to client. Uploading FlubuCore scripts to the server where web api is deployed. Automatic updates Manual target execution through FlubuCore web app(deployed together with web api) In this getting started tutorial we will: Deploy FlubuCore web api to the server. Write .net deployment script that will deploy mvc example application on the sever. You should go through this tutorial even if you want to use FlubuCore.WebApi for .net core application deployment. There are few small differences between using FlubuCore.WebApi for deploying .net core applications and .net applications. All differences are written in this tutorial. Write build script that will upload deployment package of the example application to the server and execute deployment script that we wrote. Run deployment script through build script remotely. Requirements \u00b6 .net 462+ runtime or .net core runtime installed on the server. Depending on which build of FlubuCore.WebApi you plan to use. Web api deployment \u00b6 Get appropriate web api deploy package from https://github.com/flubu-core/flubu.core/releases . Copy web api deployment package to the server where you want to execute flubu script. Unzip the package. Set web api deployment configuration settings in the unzipped DeploymentConfig.json file. More about specific deployment config settings can be found in the configuration file. On windows server run deploy.bat to deploy the web api On linux/mac server run: dotnet restore and after that: dotnet flubu -s=deploymentscript.cs On deployed location run dotnet FlubuCore.WebApi.dll to selfhost web api. You can of course also host it for example on iis... IIS deployment \u00b6 How to deploy asp .net core application see: https://docs.microsoft.com/en-us/aspnet/core/publishing/iis?tabs=aspnetcore2x Some actions might need administration rights like starting / stoping the application pool. If that's the case u have to change identity on the application pool where you hosted the web api. Go to Application pools -> Web api app pool -> Advanced settings -> process model -> Identity and change to user which has admin rights. Write deploy script \u00b6 Example .net deploy script can be found Here . If u want to try the example the best way is to just clone the flubu core examples directory. Deploy script for .net core application would be of course slightly different. Example deploy script for .net application will Create iis application pool if it doesnt exists Stop the application pool Unzip package from /packages directory(which will be uploaded to web api with build script) Copy unziped application to new folder where it is/will be hosted. Create web site on iis for example web application Start the application pool When you finish writing your deploy script manually copy it to web api deployed location /scripts folder. Web api can also upload scripts but it is disabled by default for obvious security reason. It should stay disabled in most cases. If needed modify Example DeployScript for your needs. Write build script \u00b6 Example .net build script can be found here Example .net build script will Get the authentication token Delete old packages from /packages folder on web api. Upload package to web api /packages folder Execute Deployment script in /scripts folder that we manually uploaded If needed modify Example BuildScript for your needs. Run deploy script \u00b6 If u cloned example repository just execute at the root foolder: dotnet restore buildscript.csproj and dotnet flubu deploy -s=buildscript\\buildscript.cs in cmd from DeployScriptExample folder In real case scenario you would probably deploy from your build server after sucesfull build, after merge to release branch, manually execute the job on build server... Security \u00b6 As attacker can do alot of damage if he gains access to web api next security measures should be implemented if possible: If possible Flubu web api should not be publicly accessible. Always host web api on https. Restrict access by ip(config). Restrict access by time frame(config). This security measure should be taken if you deploy your application always at same time e.g 11pm. Then time frame when api can be accessed should be set for example from 11pm to 11.15pm, Use very strong password(web api user creation). Do not disable feature \"Restrict access on failed login\"(config). Enable email notifications when GetToken/Script is executed on api(config). For detailed description of security settings see appsettings.json file on web api. Automatic update \u00b6 You can automatically update FlubuCore web api if new version is available. Just navigate to /UpdateCenter (not /api/UpdateCenter) Manual target execution remotely through FlubuCore web app \u00b6 You can manually execute target through FlubuCore web app. Just navigate to /Script","title":"Getting started"},{"location":"WebApi/getting-started/#about","text":"With FlubuCore web api you can execute FlubuCore scripts remotely. Mainly it is meant to automate deployment of .net or .net core applications from your build server to different environments but it can be used for any other FlubuCore script execution. Web Api supports: Executing flubu scripts on the server where web api is deployed. Uploading (deploy or any other) packages to the server where web api is deployed. Deleting packages from server where web api is deployed. Sending reports back to client. Uploading FlubuCore scripts to the server where web api is deployed. Automatic updates Manual target execution through FlubuCore web app(deployed together with web api) In this getting started tutorial we will: Deploy FlubuCore web api to the server. Write .net deployment script that will deploy mvc example application on the sever. You should go through this tutorial even if you want to use FlubuCore.WebApi for .net core application deployment. There are few small differences between using FlubuCore.WebApi for deploying .net core applications and .net applications. All differences are written in this tutorial. Write build script that will upload deployment package of the example application to the server and execute deployment script that we wrote. Run deployment script through build script remotely.","title":"About"},{"location":"WebApi/getting-started/#requirements","text":".net 462+ runtime or .net core runtime installed on the server. Depending on which build of FlubuCore.WebApi you plan to use.","title":"Requirements"},{"location":"WebApi/getting-started/#web-api-deployment","text":"Get appropriate web api deploy package from https://github.com/flubu-core/flubu.core/releases . Copy web api deployment package to the server where you want to execute flubu script. Unzip the package. Set web api deployment configuration settings in the unzipped DeploymentConfig.json file. More about specific deployment config settings can be found in the configuration file. On windows server run deploy.bat to deploy the web api On linux/mac server run: dotnet restore and after that: dotnet flubu -s=deploymentscript.cs On deployed location run dotnet FlubuCore.WebApi.dll to selfhost web api. You can of course also host it for example on iis...","title":"Web api deployment"},{"location":"WebApi/getting-started/#iis-deployment","text":"How to deploy asp .net core application see: https://docs.microsoft.com/en-us/aspnet/core/publishing/iis?tabs=aspnetcore2x Some actions might need administration rights like starting / stoping the application pool. If that's the case u have to change identity on the application pool where you hosted the web api. Go to Application pools -> Web api app pool -> Advanced settings -> process model -> Identity and change to user which has admin rights.","title":"IIS deployment"},{"location":"WebApi/getting-started/#write-deploy-script","text":"Example .net deploy script can be found Here . If u want to try the example the best way is to just clone the flubu core examples directory. Deploy script for .net core application would be of course slightly different. Example deploy script for .net application will Create iis application pool if it doesnt exists Stop the application pool Unzip package from /packages directory(which will be uploaded to web api with build script) Copy unziped application to new folder where it is/will be hosted. Create web site on iis for example web application Start the application pool When you finish writing your deploy script manually copy it to web api deployed location /scripts folder. Web api can also upload scripts but it is disabled by default for obvious security reason. It should stay disabled in most cases. If needed modify Example DeployScript for your needs.","title":"Write deploy script"},{"location":"WebApi/getting-started/#write-build-script","text":"Example .net build script can be found here Example .net build script will Get the authentication token Delete old packages from /packages folder on web api. Upload package to web api /packages folder Execute Deployment script in /scripts folder that we manually uploaded If needed modify Example BuildScript for your needs.","title":"Write build script"},{"location":"WebApi/getting-started/#run-deploy-script","text":"If u cloned example repository just execute at the root foolder: dotnet restore buildscript.csproj and dotnet flubu deploy -s=buildscript\\buildscript.cs in cmd from DeployScriptExample folder In real case scenario you would probably deploy from your build server after sucesfull build, after merge to release branch, manually execute the job on build server...","title":"Run deploy script"},{"location":"WebApi/getting-started/#security","text":"As attacker can do alot of damage if he gains access to web api next security measures should be implemented if possible: If possible Flubu web api should not be publicly accessible. Always host web api on https. Restrict access by ip(config). Restrict access by time frame(config). This security measure should be taken if you deploy your application always at same time e.g 11pm. Then time frame when api can be accessed should be set for example from 11pm to 11.15pm, Use very strong password(web api user creation). Do not disable feature \"Restrict access on failed login\"(config). Enable email notifications when GetToken/Script is executed on api(config). For detailed description of security settings see appsettings.json file on web api.","title":"Security"},{"location":"WebApi/getting-started/#automatic-update","text":"You can automatically update FlubuCore web api if new version is available. Just navigate to /UpdateCenter (not /api/UpdateCenter)","title":"Automatic update"},{"location":"WebApi/getting-started/#manual-target-execution-remotely-through-flubucore-web-app","text":"You can manually execute target through FlubuCore web app. Just navigate to /Script","title":"Manual target execution remotely through FlubuCore web app"}]}